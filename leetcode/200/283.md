# [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)

### 출처 LeetCode
[283. Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)

#### 시간 복잡도
**n(1 <= nums.length <= 10^4)**   
$`O(n)`$

#### 문제 유형
구현  
Array

#### 문제 풀이

### c++ 풀이
- Runtime: 0ms
- Beats: 100.00%
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n=nums.size();
        int zero=count(nums.begin(), nums.end(), 0);
        vector<int> ans;
        for(int i : nums) {
            if(i) ans.push_back(i);
        }
        while(zero--) {
            ans.push_back(0);
        }
        for(int i=0; i<n; ++i) {
            nums[i]=ans[i];
        }
    }
};
```

### 다른 사람 풀이
- Runtime: 0ms
- Beats: 100.00%
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
          int i=0;
          for(int j=0;j<nums.size();j++){
              if(nums[j]!=0){
                if(j!=i){
                swap(nums[j],nums[i]);
                }
                i++;
            }
        
        }
          
    }
};
```

### 공식 해설
#### 접근법 1: Space Sub-Optimal (비효율적인 공간 사용)
간단한 접근 방식 중 하나는 배열에서 0의 개수를 세고, 새 배열 `ans`를 만들어서 0이 아닌 값을 차례대로 추가한다.  
0의 개수만큼 0을 `ans`에 추가하고, `ans`를 `nums` 복사한다.

##### 알고리즘
- `nums`의 길이를 `n`에 저장
- `nums`를 순회하면서 0의 개수를 센다:
    - `numZeroes`를 0으로 초기화
    - `nums`의 각 요소를 순회:
        - 요소의 값이 0이면 `numZeroes`의 값을 증가
- 0이 아닌 요소를 순서대로 저장하기 위해 `ans` 벡터를 생성:
    - 0이 아닌 값을 `ans`에 추가
- `numZeroes`만큼 0을 `ans`에 추가
- `ans`를 `nums`에 복사

##### 복잡도 분석
- 시간 복잡도: $`O(n)`$
- 공간 복잡도: $`O(n)`$
```c++
class Solution {
public:
  void moveZeroes(vector<int>& nums) {
      int n = nums.size();

      // Count the zeroes
      int numZeroes = 0;
      for (int i = 0; i < n; i++) {
          numZeroes += (nums[i] == 0);
      }

      // Make all the non-zero elements retain their original order.
      vector<int> ans;
      for (int i = 0; i < n; i++) {
          if (nums[i] != 0) {
              ans.push_back(nums[i]);
          }
      }

      // Move all zeroes to the end
      while (numZeroes--) {
          ans.push_back(0);
      }

      // Combine the result
      for (int i = 0; i < n; i++) {
          nums[i] = ans[i];
      }
  }
};
```

#### 접근법 2: Space Optimal, Operation Sub-Optimal (공간 최적화, 연산 비최적화)
두 개의 포인터를 사용해서 **non-zero** 원소를 앞으로 옮기고(순서 유지), 나머지는 0으로 채운다.

##### 알고리즘
- `lastNonZeroFoundAt`을 0으로 초기화
- `nums` 순회:
    - 만약 `nums[i] != 0` 이면:
        - `nums[lastNonZeroFoundAt] = nums[i]`
        - `lastNonZeroFoundAt` 증가
- 배열의 나머지 부분 (from `lastNonZeroFoundAt` to end):
    - 전부 0으로 채우기

##### 복잡도 분석
- 시간 복잡도: $`O(n)`$
- 공간 복잡도: $`O(1)`$
```c++
class Solution {
public:
  void moveZeroes(vector<int>& nums) {
      int lastNonZeroFoundAt = 0;
      // If the current element is not 0, then we need to
      // append it just in front of last non 0 element we found.
      for (int i = 0; i < nums.size(); i++) {
          if (nums[i] != 0) {
              nums[lastNonZeroFoundAt++] = nums[i];
          }
      }
    // After we have finished processing new elements,
    // all the non-zero elements are already at beginning of array.
    // We just need to fill remaining elements in the array with 0's.
      for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {
          nums[i] = 0;
      }
  }
};
```

#### 접근법 3: Optimal (최적화)
투 포인터와 조건부 스왑으로 불필요한 덮어쓰기를 최소화해서, **실제 array write 횟수를 줄인다.**

##### 알고리즘
- `lastNonZeroFoundAt`을 0으로 초기화
- `nums` 순회:
    - `nums[cur] != 0` 이면:
        - `swap(nums[lastNonZeroFoundAt], nums[cur])`
        - `lastNonZeroFoundAt` 증가        
    - `cur` 증가(항상 이동)

##### 복잡도 분석
- 시간 복잡도: $`O(n)`$
- 공간 복잡도: $`O(1)`$
```c++
class Solution {
public:
  void moveZeroes(vector<int>& nums) {
      for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {
          if (nums[cur] != 0) {
              swap(nums[lastNonZeroFoundAt++], nums[cur]);
          }
      }
  }
};
```