# [707. Design Linked List](https://leetcode.com/problems/design-linked-list/description/)

### 출처 LeetCode
[707. Design Linked List](https://leetcode.com/problems/design-linked-list/description/)

#### 시간 복잡도

#### 문제 유형
구현  
Linked List

#### 문제 풀이

### c++ 풀이
- Singly Linked List 구현
- Runtime: 10ms
- Beats: 45.82%
```c++
struct Node {
    int val;
    Node* next;
    Node(int x) : val(x), next(nullptr) {}
};
class MyLinkedList {
private:
    int size;
    Node* head;

public:
    MyLinkedList() {
        size = 0;
        head = nullptr;        
    }
    
    int get(int index) {
        if (index < 0 || index >= size) return -1;

        Node* current = head;
        for(int i = 0; i < index; i++) {
            current = current->next;
        }

        return current->val;
    }
    
    void addAtHead(int val) {
        Node* newNode = new Node(val);
        newNode->next = head;
        head = newNode;
        ++size;
    }
    
    void addAtTail(int val) {
        Node* newNode = new Node(val);

        if (!head) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next) {
                current = current->next;
            }
            current->next = newNode;
        }

        ++size;
    }
    
    void addAtIndex(int index, int val) {
        if (index < 0 || index > size) return;
        
        if (index == 0) {
            addAtHead(val);
        } else {
            Node* newNode = new Node(val);
            Node* current = head;
            for (int i = 0; i < index - 1; ++i) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
            ++size;
        }        
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        if (index == 0) {
            Node* delNode = head;
            head = head->next;
            delete delNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            
            Node* delNode = current->next;
            current->next = current->next->next;
            delete delNode;
        }
        --size;
    }
};
```

- doubly Linked List 구현
```c++
class MyLinkedList {
private:
    struct Node {
        int val;
        Node* next;
        Node* prev;
        Node(int v) : val(v), next(nullptr), prev(nullptr) {}
    };

    Node* head;
    Node* tail;
    int size;

public:
    MyLinkedList() {
        head = nullptr;
        tail = nullptr;
        size = 0;
    }

    int get(int index) {
        if (index < 0 || index >= size) return -1;

        Node* curr;
        if (index < size / 2) {
            curr = head;
            for (int i = 0; i < index; ++i) {
                curr = curr->next;
            }
        } else {
            curr = tail;
            for (int i = size - 1; i > index; --i) {
                curr = curr->prev;
            }
        }
        return curr->val;
    }

    void addAtHead(int val) {
        Node* node = new Node(val);
        node->next = head;
        if (head) head->prev = node;
        head = node;
        if (size == 0) tail = node;
        size++;
    }

    void addAtTail(int val) {
        Node* node = new Node(val);
        node->prev = tail;
        if (tail) tail->next = node;
        tail = node;
        if (size == 0) head = node;
        size++;
    }

    void addAtIndex(int index, int val) {
        if (index < 0 || index > size) return;

        if (index == 0) {
            addAtHead(val);
        } else if (index == size) {
            addAtTail(val);
        } else {
            Node* curr;
            if (index < size / 2) {
                curr = head;
                for (int i = 0; i < index; ++i) {
                    curr = curr->next;
                }
            } else {
                curr = tail;
                for (int i = size - 1; i > index; --i) {
                    curr = curr->prev;
                }
            }

            Node* node = new Node(val);
            node->prev = curr->prev;
            node->next = curr;

            curr->prev->next = node;
            curr->prev = node;
            size++;
        }
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;

        Node* curr;
        if (index < size / 2) {
            curr = head;
            for (int i = 0; i < index; ++i) {
                curr = curr->next;
            }
        } else {
            curr = tail;
            for (int i = size - 1; i > index; --i) {
                curr = curr->prev;
            }
        }

        if (curr->prev) curr->prev->next = curr->next;
        else head = curr->next;

        if (curr->next) curr->next->prev = curr->prev;
        else tail = curr->prev;

        delete curr;
        size--;
    }
};
```

### 다른 사람 풀이
- Runtime: 0ms
- Beats: 100.0%
```c++
class Node{
public:
    int val;
    Node* next=NULL;

    Node(int x){
        val=x;
        next=NULL;
    }
};

class MyLinkedList {
public:
    Node* head;
   
    MyLinkedList() {
        head=NULL;
    }
    
    int get(int index) {
        if(!head) return -1;   // fix: return -1 if list empty
        Node* temp=head;
        int i=0;
        while(temp){
            if(i==index) return temp->val;   // fix: use 0-based index
            i++;
            temp=temp->next;
        }
        return -1;  // if index out of range
    }
    
    void addAtHead(int val) {
        if(!head){
            head=new Node(val);
        }
        else{
            Node* temp=new Node(val);
            temp->next=head;
            head=temp;
        }
    }
    
    void addAtTail(int val) {
        if(!head) head=new Node(val);
        else{
            Node* temp=head;
            while(temp->next){
                temp=temp->next;
            }
            temp->next=new Node(val);
        }
    }
    
    void addAtIndex(int index, int val) {
        if(index==0){   // fix: inserting at head
            addAtHead(val);
            return;
        }
        Node* temp=head;
        Node* prev=NULL;
        int i=0;
        while(temp && i<index){
            prev=temp;
            temp=temp->next;
            i++;
        }
        if(i!=index) return; // fix: index out of range
        Node* node=new Node(val);
        if(prev){
            prev->next=node;
            node->next=temp;
        }
    }
    
    void deleteAtIndex(int index) {
        if(!head) return;   // fix: just return if empty
        if(index==0){       // fix: deleting head
            Node* temp=head;
            head=head->next;
            delete temp;
            return;
        }
        Node* prev=NULL;
        Node* temp=head;
        int i=0;
        while(temp && i<index){
            prev=temp;
            temp=temp->next;
            i++;
        }
        if(!temp) return; // fix: index out of range
        if(prev){
            prev->next=temp->next;
            delete(temp);
        }
    }
};
```